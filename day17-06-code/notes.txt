获取线程的名称：
    1.使用Thread类中的getName()方法
        String getName() 返回线程的名称
    2.可以先获取当前正在执行的线程，使用线程中的getName()方法获取线程的名称
        static Thread currentThread() 返回对当前正在执行的线程对象的索引



/~~/


设置线程的名称(了解)
    1.使用Thread类中的setName(名字)
        void setName(String name) 改变线程名称，使之与参数 name 相同。
    2.创建一个带参数的构造方法，参数传递线程的名称；在这个构造方法中调用父类的带参构造方法，把线程名称传递给父类，让父类(Thread)给子类线程起一个名字
        Thread(String name) 分配新的 Thread 对象。


/~~/


static void sleep(long millis)  在指定的毫秒数内让当前正在执行的线程休眠（暂停执行
    毫秒数结束之后，线程继续执行



/~~/


创建多线程程序的第二种方式：实现Runnable接口
    java.lang.Runnable
        Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法
    java.lang.Thread类的构造方法
        Thread(Runnable target) 分配新的 Thread 对象。
        Thread(Runnable target, String name) 分配新的 Thread 对象。

实现步骤：
    1.创建一个Runnable类接口的实现类
    2.在实现类中重写Runnable接口的run()方法，设置线程任务
    3.创建一个Runnable接口的实现类对象
    4.创建Thread类对象，构造方法中传递Runnable接口的实现类对象。
    5.调用Thread类中的start()方法，开启新的线程执行run()方法。

实现Runnable接口创建多线程程序的好处
    1.避免了单继承的局限性
        一个类只能继承一个父类，一个类继承了Thread类之后就不能继承其他类了
        实现了Runnable接口,还可以继承其他类，实现其他接口
    2.增强了程序的扩展性，降低了程序的耦合性(解耦)
        实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离(解耦)
        实现类中重写了run()方法：用来设置线程任务
        创建Thread类对象，调用start()方法

推荐使用第二种方式开启多线程任务


/~~/


匿名内部类实现线程的创建
    匿名：没有名字
    内部类：写在其他类内部的类
    匿名内部类的作用：简化代码
        把子类继承父类，重写父类的方法，创建子类对象合成一步
        把实现类实现接口，重写接口中的方法，创建实现类对象合成一步完成。
    匿名内部类的最终产物：子类/实现类对象，而这个类没有名字

    格式：
        new 父类/接口(){
            重写父类/接口中的方法
        };



/~~/


卖票案例出现了线程安全问题
卖出了不存在的票和重复的票

解决线程安全问题的第一种方式：使用同步代码块
格式：
    synchronized(锁对象){
        可能出现线程安全的代码块(访问了共享数据的代码块)
    }

注意：
    1.通过代码块中的锁对象，可以使用任意对象
    2.但是保证多个线程使用的锁对象是同一个
    3.锁对象的作用：
        把同步代码块锁住，只让一个线程在同步代码块中执行


/~~/



卖票案例出现了线程安全问题
卖出了不存在的票和重复的票

解决线程安全的第二种方案：使用同步方法
使用步骤：
    1.把访问了共享数据的代码抽取出来，放到一个方法中
    2.在方法上添加synchronized修饰符

格式：
    修饰符 synchronized 返回值类型 方法名(参数列表){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }


/~~/


等待唤醒案例：线程之间的通信
    创建一个顾客线程(消费者)：告知老板要的包子的种类和数量，调用wait()方法，放弃cpu的执行，进入到WAITING状态(无限等待)
    创建一个老板线程(生产者)：花了5秒做包子，做好包子之后，调用notify()方法，唤醒顾客吃包子
注意：
    顾客和老板线程必须使用同步代码块包裹起来，保证等待与唤醒只能有一个在执行
    同步锁对象必须保证唯一
    只有锁对象才能调用wait()和notify()方法

Object类中的方法
    void wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
    void notify() 唤醒在此对象监视器上等待的单个线程。会继续执行wait()方法之后的代码



/~~/


进入到TimeWaiting(计时等待)有两种方式
    1.使用sleep(Long m)方法，在毫秒值结束之后，线程睡醒进入到Runnable/Blocked状态
    2.使用wait(Long m)方法，wait()方法如果在毫秒值结束之后，还没有被notify()唤醒，就会自动醒来，线程睡醒进入到Runnable/Blocked状态

唤醒方法：
    void notify() 唤醒在此对象监视器上等待的单个线程。
    void notifyAll() 唤醒在此对象监视器上等待的所有线程。

