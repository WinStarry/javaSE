接口就是一种公共的规范标准。只要符合规范标准，就可以大家通用。

接口就是多个类的公共规范
接口是一种引用数据类型，最重要的内容就是其中的：抽象方法

接口的定义格式：
public interface 接口名称 {
       //接口内容
}

备注：
关键字由class换成interface之后，编译生成的字节码文件仍然是：.java ---> .class

如果是Java 7，那么接口中可以包含的内容有：
    1.常量
    2.抽象方法

如果是Java 8，还可以额外包含有：
    3.默认方法
    4.静态方法

如果是Java 9，还可以包含有：
    5.私有方法

/~~/

任何版本的Java中，接口都可以定义抽象方法
格式：
public abstract 返回值类型 方法名称(参数列表);

注意事项：
    1.接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract
    2.这两个关键字 修饰符，可以选择性地省略
    3.方法的三要素，可以随意定义。

public interface MyInterfaceAbstract {
    public abstract void methodAbs1();//这是一个抽象的方法
    void methodAbs2();//这也是抽象方法
    abstract void methodAbs3();//这也是抽象方法
    public void methodAbs4();//这也是抽象方法
}

/~~/

接口的使用步骤：
1.接口不能直接使用，必须有一个"实现类"来"实现"该接口。
格式：
public class 实现类名称 implements 接口名称 {
    //...
}
2.接口的实现类必须覆盖重写（实现）接口中的所有的抽象方法。
实现：去掉abstract关键字，加上方法体大括号。
3.创建实现类的对象，进行使用。

注意事项：
如果实现类并没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类。

/~~/

从Java 8开始，接口中允许定义默认方法。
默认方法的格式：
public default 返回值类型 方法名称(参数列表){
    //...
}

默认方法是会被实现类继承下去的
备注：接口当中的默认方法，可以解决接口升级的问题。

注意事项：
1.接口的默认方法可以通过接口实现类对象直接调用
2.接口的默认方法也可以被接口实现类进行覆盖重写。

/~~/

从Java 8开始，接口中允许定义静态方法。

静态方法的定义格式：
public static 返回值类型 方法名称(参数列表){
    方法体;
}
提示：就是将abstract或者default换成static即可，带上方法体。

注意事项：不能通过接口实现类的对象来调用接口中的静态方法。
正确用法：通过接口名称，直接调用其中的静态方法。
格式：
接口名称.静态方法名(参数);

/~~/

问题描述：
我们需要抽取一个共性方法，用来解决两个默认方法之间重复代码的问题，
但是这个共有的方法不应该让实现类使用，应该是私有化的。

解决方案：
从Java 9开始，接口中允许定义私有方法
1.普通私有方法，解决多个默认方法之间重复代码问题。
格式：
private 返回值类型 方法名称(参数列表) {
    方法体;
}

2.静态私有方法，解决多个静态方法之间重复代码问题。
格式：
private static 返回值类型 方法名称(参数列表) {
    方法体;
}

/~~/

接口中也可以定义“成员变量”，但是必须使用public static final 三个关键字进行修饰。
从效果上看，这其实就是接口的【常量】
格式：
public static final 数据类型 常量名称 = 数据值;

备注：
一旦使用final关键字进行修饰，说明不可改变。

注意事项：
1.接口中的常量，可以省略public static final ,注意：不写也照样是这样！
2.接口中的常量，必须进行赋值，不能不赋值。
3.接口中的常量的名称，使用完全大写的字母，用下划线进行分割。（推荐的命名规则）

/~~/

在Java9+版本中，接口的内容可以有：
下面的[]中的关键字是可以随意省略不写的！

1.成员变量其实是常量，格式：
[public] [static] [final] 数据类型 常量名称 = 数据值;
注意：
    常量必须进行赋值，而且一旦赋值不能改变。
    常量名称完全大写，用下划线进行分割。
    public static final 这三个关键字可以随意省略，不影响使用效果。

2.接口中最重要的就是抽象方法，格式：
[public] [abstract] 返回值类型 方法名称(参数列表);
注意：
    实现类必须覆盖重写接口中所有的抽象方法，除非实现类是抽象类。

3.从java8开始，接口中允许定义默认方法，格式：
[public] default 返回值类型 方法名称(参数列表){方法体}

4.从Java8开始，接口中允许定义静态方法，格式：
[public] static 返回值类型 方法名称(参数列表){方法体}
注意：
    应该通过接口名进行调用，不能通过实现类对象调用静态方法。

5.从Java9开始，接口里允许定义私有方法，格式：
普通私有方法：private 返回值类型 方法名称(参数列表){方法体}
静态私有方法：private static 返回值类型 方法名称(参数列表){方法体}
注意：
    private的方法只有接口自己才能调用，不能被实现类或别人使用。

/~~/

使用接口的时候，需要注意：
1.接口是没有静态代码块或者构造方法的
2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
格式：
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
    //覆盖重写所有抽象方法
}
3.如果实现类所实现的多个接口中存在重复的抽象方法，那么只需要覆盖重写一次即可。
4.如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类就必须是一个抽象类。
5.如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6.一个类 如果直接父类中的方法，和接口中的默认方法产生了冲突，优先使用父类中的方法。
    原因：在Java中，继承是要优先于接口实现的

/~~/

1.类与类之间是单继承的。直接父类只有一个。
2.类与接口之间是多实现的。一个类可以实现多个接口。
3.接口与接口之间是多继承的，
    public interface extends interfaceA, interfaceB {}

注意事项：
1.多个父接口中的抽象方法如果重复，没有关系
2.多个父接口中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】

/~~/

extends继承或者implements实现，是多态性的前提。

小明是一个对象，这个对象既有学生形态，也有人类形态。
一个对象拥有多种形态，这就是：对象的多态性。

代码当中体现多态性，其实就是一句话：父类引用指向子类对象。
格式：
父类名称 对象名 = new 子类名称();
或者：
接口名称 对象名 = new 实现名称();

访问成员变量的两种方式：
1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。

在多态中，成员方法的访问规则是：
    看new的是谁，就优先用谁 ，没有则向上找
口诀：编译看左边，运行看右边


对比一下：
成员变量：编译看左边，运行还看左边
成员方法：编译看左边，运行看右边

/~~/

使用多态的好处：
    无论右边new的时候换成哪个子类对象，等号左边调用方法都不会发生变化。

/~~/

1.对象的向上转型，其实就是 多态的写法
格式：父类名称 对象名 = new 子类名称();
含义：右侧创建一个子类对象，把它当作父类来看待使用。
Animal animal = new Cat();
创建了一只猫，当作动物看待，没问题。
类似于：
double num = 100; //正确，int ---> double 自动类型转换
注意事项：
向上转型一定是安全的。从小范围转向了大范围。从小范围的猫，向上转换成为更大范围的动物。
向上转型的一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。
此弊端的解决方案：用对象的向下转型【还原】

2.对象的向下转型，其实是一个【还原】的动作。
格式：子类名称 对象名 = (子类名称) 父类对象;
含义：将父类对象【还原】成为本来的子类对象。
Animal animal = new Cat(); // 本来是猫，向上转型为动物
Cat cat = (Cat) animal; //本来是猫，已经被当作动物了，还原回来成为本来的猫。
类似于：
int num = (int) 10.0;//可以
int num = (int) 10.5;//不可以 ，精度损失
注意事项：
    必须保证对象本来创建的时候，就是猫，才能向下转型成为猫
    如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会报错。


如何才能知道一个父类引用的对象，本来是什么样子？
格式：
对象 instanceof 类名称
这将会得到一个boolean值结果，也就是判断前面的对象能不能当作后面类型的实例

Animal animal = new Cat();
animal.eat();
//如果需要调用子类特有的方法，需要向下转型
//判断一下父类引用animal本来是不是Dog
if(animal instanceof Cat){
    Dog dog = (Dog) animal;
    dog.watchHouse();
}
//判断一下animal本来是不是Cat
if(animal instanceof Cat){
    Cat cat = (Cat) animal;
    cat.catchMouse();
}




