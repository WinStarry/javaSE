final关键字代表最终的、不可改变的
常见的4中用法
1.可以用来修饰一个类
2.可以用来修饰一个方法
3.可以用来修饰一个局部变量
4.可以用来修饰一个成员变量

/~~/

当final关键字用来修饰一个类的时候，格式：
public final class 类名称 {
    //...
}

含义：当前这个类不能有任何子类。（太监类）
注意事项：
    不能使用一个final类作为父类！
    一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为不能有儿子）

/~~/

当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。
格式：
修饰符 final 返回值类型 方法名称(参数列表){
    //方法体
}

注意事项：
    对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
    一个是一定要被覆盖重写，一个是不能被覆盖重写。

/~~/

一旦使用final来修饰局部变量，那么这个变量就不能进行更改。
final int num = 10; //一次赋值，终生不变！

//下面写法是正确的，只要保证有唯一一次赋值即可
final int num;
num = 10;

对于基本数据类型来说，不可变说的是变量中的数据不可改变
对于引用数据类型来说，不可变说的是变量中的地址值不可改变

/~~/

对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。
1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一
3.必须保证类当中的所有重载的构造方法，都最终会对final的成员变量进行赋值。

/~~/

java中有4种权限修饰符
                public > protected > (default) > private
同一个类            YES     YES         YES         YES
同一个包            YES     YSE         YES         NO
不同包子类          YES     YES          NO         NO
不同包非子类        YES     NO           NO         NO

记忆技巧：
同一个类（我自己）、同一个包（我邻居）、不同包子类（我儿子）、不同包非子类（陌生人）
注意事项：
    (default)并不是关键字"default"，而是根本不写。

/~~/

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。

分类：
1.成员内部类
2.局部内部类（包含匿名内部类）

成员内部类的定义格式：
修饰符 class 外部类名称 {
    修饰符 class 内部类名称{
        //...
    }
    //...
}
注意事项：内用外，随意访问；外用内，需要内部类对象。

如何使用内部类？有两种方法：
1.间接方式：在外部类的方法中创建内部类的对象，使用内部类对象调用内部类的方法；
           然后main方法中创建外部类的对象调用外部类的方法，这样就可以间接使用内部类的方法了。
2.直接方式，公式：
类名称 对象名 = new 类名称();
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();

/~~/

内部类的同名变量访问
如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名

/~~/

如果一个类是定义在一个方法内部的，那么就是一个局部内部类。
“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

定义格式：
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表){
        class 局部内部类名称 {
            //...
        }
    }
}

小节一下类的权限修饰符：
public > protected > (default) > private
定义一个类的时候，权限修饰符规则：
1.外部类： public / (default)
2.成员内部类： public / protected / (default) / private
3.局部内部类： 什么都不能写

/~~/

局部内部类的final问题
局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】
备注:从Java8+开始，只要局部变量事实不变，那么final关键字可以省略。

原因：
1.new出来的对象在堆内存中
2.局部变量跟着方法走，在栈内存中
3.方法运行结束后，立刻出栈，局部变量就会消失。
4.但是new出来的对象会在堆中持续存在，直到垃圾回收消失。

/~~/

如果接口的实现类（或者是父类的子类）只需要使用唯一一次，那么这种情况况下可以省略该类的定义，
而改为使用【匿名内部类】

匿名内部类的定义格式：
接口名称 对象名 = new 接口名称(){
    //覆盖所有抽象方法
};

对格式“new 接口名称(){...}”进行解析：
1.new代表创建对象的动作
2.接口名称就是匿名内部类需要实现哪个接口
3.{...}这才是匿名内部类的内容

另外还要注意几件事：
1.匿名内部类，在【创建对象】的时候，只能使用唯一一次。
    如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。
2.匿名对象，在【调用方法】的时候，只能使用唯一一次。
    如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
3.匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】
强调：匿名内部类和匿名对象不是一回事！

/~~/

类作为成员变量的类型
任何一种数据类型都可以作为成员变量的类型。